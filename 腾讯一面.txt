腾讯一面.mp3
说话人1 00:02
行，然后你现在是毕业以后直接在唯品会去开始实习吗？还是说正式工作
说话人2 00:09
不是实习
说话人1 00:11
我理解你不是毕业了吗？应该是直接找正式岗就好了，为什么是一个实习的岗位？
说话人2 00:17
因为我之前在美国找实习的时候没有找到，然后我的简历里面就没有实习经验，然后找正式的时候就不太好找，所以就先找一段实习。
说话人1 00:29
好，也就是说你其实不想留在委员会是吧？想混一个实习经验之类的东西，然后后边的话再想找工作，是这个意思吧？
说话人2 00:37
对，如果满意的话考虑留下来的。因为唯品会在天津那边，然后我想去江浙沪或者是珠三角。
说话人1 00:50
Ok江浙沪说你现在实习我看应该有5个月，到现在应该8个月了，对吧？也一直在吧？
说话人2 00:58
没有5月就结束了。
说话人1 01:01
你现在在干啥？
说话人2 01:04
我现在在找工作，因为我我家里有点事情，然后就没有继续没有留住保证，
说话人1 01:13
所以你后边的话不也跟他后来有留用你吗？还是说你自己又就主动离开了？
说话人2 01:20
是有可以转正，但是是在天津，我个人不太想待在天津。
说话人1 01:26
懂了ok吧？行，我们今天的话先做一个笔试，然后后边的话再看一下你的简历方面的一些事情。
我这样我在代码考核这个地方出个题，好
说话人2 01:40
的，今天是只有笔试没有就是8股的吗？
说话人1 01:48
也不叫8股，过一下你的简历应该是有的，就看你笔试的结果。笔试是第一关，

你就听听这个题本身就是大数的10进制，然后转二进制输出这个题就是大数的话最大能到它的64次方以上，就这么简单的一个东西。
说话人2 07:15
要请问这个输入是一个字符串还是一个就是数字呢？
说话人3 07:21
字符串。
说话人2 14:18
我先说一下思路，面试官
说话人1 14:24
其实这个题思路也比较简单，你现在是直接做看能不能做得出来，
说话人2 14:33
ok。
说话人2 21:51
你好，我好像写完了。
说话人1 21:54
你看调试一个123456789
说话人1 22:21
直接hardcode写在代码里，对。
说话人2 22:42
等一下有异常我看一下，
说话人1 23:16
你这个地方我看你这么写的话，它如果超过二的64次方，你这咋整？现在是存不下的，
说话人2 28:56
您看一下。我有一个结果，但是我没有办法验证这个结果对不对？
说话人1 29:08
我看你怎么实现的4周。
说话人1 29:34
 Ok你的结果你可以拿计算器，你直接拿自己的计算器去看一下这个结果就好了。
说话人2 29:43
这个好像
说话人1 29:47
计算器不是可以直接转吗？
说话人2 29:50
太长了，我可以直接就丢到浏览器里，让浏览器帮我算一下
说话人1 29:59
我帮你看看，
说话人1 30:05
结果应该是对的，我再看一下你的视线，
说话人2 30:13
然后加上这一行就好了，加上这一行是因为他之前的外部循环可能会导致那么是空，然后为空了就说明那么是0，然后就直接退出
说话人1 30:29
Ok。问题不大，行，我们再聊一聊你的简历。
说话人2 30:35
只有一道吗？
说话人1 30:38
对，你想再来一道吗？
说话人2 30:39
不想，
说话人1 30:41
我刷题刷的头疼，
说话人1 30:45
我看你是首先220年毕业之后，然后21年才入的职。你中间一年是去干啥了？
说话人2 30:55
我之前是考华中科技大，然后被调剂了，
说话人1 31:00
然后又重新考了一年，然后这是怎么样，
说话人2 31:03
然后申请出国了。
说话人1 31:06
中间一年这一年主要是在读预科吗？还是怎么样？
说话人2 31:13
是的。在国内上预科就是上完预科就到了那边就不用再读语言班了。
说话人1 31:24
了解互联网。行，我们主要聊一下你唯品会这块经历。你唯品会这边的话，我看实习了大概5个月，然后做了这个项目，你能大概表述一下是干啥的吗？
说话人2 31:40
好的，这个项目大概是一个规则引擎，然后它主要的作用目的就是为了把业务模块里面的就是一些规则判定，它不好意思，因为他业务判定是硬编码在业务逻辑里面之前，然后我们做的就是为了把它从一边把它解放出来，然后用一个规则脚本的形式放在一个规则引擎里面，然后就等其他业务系统来调用我们。
说话人1 32:21
怎么来解释这个规则引擎，你能举几个例子吗？
说话人2 32:25
可以的。我再详细介绍一下它的背景，然后
为了从一边把你解放出来，然后他这是他的业务背景，然后他其实还有一个技术背景，然后他技术背景，第一个是他业务和技术耦合了，然后他第二个就是这个东西比较难使用，它出错率比较高。
然后我们对接的业务有有几个4个，有积分系统，然后有风控系统，然后有有告警系统，然后还有一个权限系统，然后比如积分系统告警系统，它自己去实现这么一个逻辑复杂的这么一个组合，他们维护起来就比较困难，然后有规则引擎之前，各个平台各个系统他自己去玩，自己去写这些东西，然后再有了这个规则引擎之后，我们就会把这个规把把这些规则它抽到这个规则引擎里面去，规则引擎这个系统里面来，然后让这些业务系统来对接这个规则引擎，然后这些业务系统它就不用去关心底层的实现了。
说话人1 33:47
你比如说是积分规则，比如说什么，比如说我做某一个动作，连续做两次加多少分，连续做三次只加多少分，你遵守吗？
说话人2 34:01
类似我们的是比如它会积分系统它会去监听用户的交易，然后如果交易发生了之后，规则引擎就会根据匹配到的规则，还有实时数据，然后去进行一些积分的计算，比如消费规则满100就积一分，然后这个就是一个积分系统的大概的样子，然后计算完成之后，积分就会结果积分变动的结果就会去更新到用户的积分余额里面，然后去记录积分变动的信息。然后在告警系统里面，比如说大型公司里面都会有监控系统来监控服务的健康状况，比如业务接口的响应时间，比如有一些性能指标，有什么 Cpu，然后有什么内存，然后我们就可以把这些数据采集出来，不是我们是业务是告警系统，它去把这些数据采集出来，然后比如说它有百分 CPU占用率80%，然后他就要去做一个告警的操作，他就会把把这些数据采集出来之后，他就会去看有没有到达某个阈值，如果达到了这个阈值，我们就要去做告警的一个动作。然后告警的动作有各种各样的，比如说发信息、打电话，然后发微信之类的，然后上个系统采集到的数据丢到我们规则引擎，然后我们规则引擎会去做一个匹配，根据之前制定的规则去做一个匹配，然后告诉他匹配上了还是没有匹配上。
说话人1 35:41
对本身你这个系统你觉得你自己负责哪一块，然后你自己比如说做这块的时候有没有发现一些问题，或者说你自己工作中有没有什么亮点？
说话人2 35:56
是有的。我之前做的有几个功能，然后有一个是业务回调，然后他在业务回调好像是
说话人2 36:13
记得问题比较清楚的是归版本管理这块，然后版本管理它首先它有一个版本号的问题，然后他它是一条规则存在它的数据库里面，然后它会根据前端人员去配置一些规则，然后它更新到我们的包装引擎里面。
然后它每次更新同一条规则的话，它因为我们在数据库的表里有一个版本号，然后他经常会去更新的话，那就有一个版本冗余的问题，
说话人2 36:50
他它有很多个版本的话，它也就是存的数据比较大，然后它包括保留之前的版本也没有什么必要，然后我们就会去进行一些版本删除的操作。那就是冗余删除，然后冗余删除。因为我们是那个服务器是有5台，然后他可能会有一些并发删除了，有有一个可能会几有并发删除的问题，可以这么说。然后我们就会通过一个 Redis来实现的分布式锁，然后分布式锁来实现单击删除的能力，谁抢到了这把锁谁就删除这条规则。
说话人1 37:46
我看你用的是乐观锁，乐观锁里边有抢就没有抢锁这个机制吗？
说话人2 37:52
不这个是冗余删除，不是乐观锁，并发修改是乐观锁。
说话人1 38:03
并发修改是乐观锁，你都说删除的时候，有人删除的时候，你就找一个主节点去抢抢这个东西是不是？
说话人1 38:16
对是的，抢到了然后就删是吧？对。你在抢主节点的时候会遇到什么问题没有？你自己加这算是分布式锁，分布式锁的话你自己有在加的时候有什么问题，
说话人2 38:38
他可能会挂掉，然后我们就会设置一个过期时间，然后再来让他如果拿到锁挂掉了，那不行，肯定让他过期的时候就把锁释放掉。
说话人1 38:52
还除了这个以外，还有没有别的问题？
说话人2 38:59
还有并发修改的问题，就是我们通过一个cas的思想来实现了并发修改，因为它的并发度不高，所以我们没有实现，我们就没有用加锁这种方式。
说话人1 39:15
比如说你刚刚回定义删除，你有过期时间吗？你的过期时间要定多久？
说话人2 39:23
大概是10秒。
说话人1 39:26
10秒，你怎么定这个10秒，你是根据什么用来做？定成10秒这个时间，
说话人2 39:33
因为他拿到锁删除这个操作也很快，然后他剩余的时间就来做一些容错，
说话人1 39:48
但是有没有可能说它超过10秒的
说话人2 39:51
一般不会，
说话人1 39:55
如果超过的话会怎么样？
说话人2 39:59
超过了的话，超过
说话人1 40:03
了你这个系统，你会穿透你这个系统能力吗？会导致不可挽回的错误，
说话人2 40:12
应该是不会的，我没有考虑到这么多，他一般来说是可能一秒内就结束了。但是我为了保证什么容错，然后就多设置了一点时间。
说话人1 40:28
比如说他这个删我的记得版本号，比如说他也是根据自这个版本号到底长还是短来看，就有可能他已经存了11万个版本了，那删就会慢，
说话人2 40:41
每天我们会有一个定时任务，然后在spring里面它有一个注解 around，然后他每天去执行，到点就去查询一下，比如说定时任务好久没跑了，好久没跑了，就不知道什么原因挂掉了，然后你现在要把它提起来的时候没有问题。
说话人2 41:09
可能会有问题。
说话人1 41:14
启动起来就存得很长了，所以你想一下它如果真的超过10秒，对于你现在这个机制来说，会不会有问题，还是说没有问题？
说话人2 41:24
可能会有问题，他删到一半了之后，他锁就被释放掉了，然后导致它版本号还是很长，冗余的问题没有解决。
说话人1 41:47
下边不是还会再去抢吗？
说话人2 41:50
下面的那是第二天的事情了吧。
说话人1 41:55
你一天执行一次是吧？
说话人2 41:57
对，
说话人1 41:58
然后一次执行10秒钟。
说话人2 42:00
是的，
说话人1 42:03
你这是相当于说针对全局的版本全上一遍是吧？
说话人3 42:10
对。
说话人1 42:10
你怎么知道你这个版本这个我理解是这个应该是个什么维度，业务维度对吧？每个业务都有一个版本号对吧？还是说每个规则都有一个版本号？
说话人2 42:23
每个规则都有个版本号，对是的，每个规则都有一个版本号。
说话人1 42:27
如果这个规则比如说有100万个规则了，你是要删不完了。
说话人2 42:33
一般来说我们是没有这么多规则的，因为
说话人1 42:38
是这只是刚做，但你你不希望他做，跑个半年就重构了，你要考虑
说话人2 42:47
是但是我也没有经验，我不太清楚你
说话人1 42:53
想假如说你现在比如说你现在有很多的这种东西，然后你觉着你应该怎么改的？
我理解你现在做的就是我一天删一次，一次就删，这10秒钟一下就完了对吧？对那好，现在就变成了你版本太多了，就删我一次删不完你要怎么办？
说话人2 43:24
那就给这个时间设置的长一点，然后他包括如果这个任务没有完成的话，就通过一个设置一个守护线程来延长锁的持有时间，
说话人1 43:42
那就变成从原来一次变成调用多次了，对吧？对。调用多次是怎么个调调用多次法呢？是一一直轮巡还是怎么着？
说话人2 44:01
也是定时。
说话人1 44:04
好，你说一下怎么定时？
说话人2 44:07
设置一个时间，因为这个时间我没有实际用过也不太清楚，但是反正要设置一个时间，然后通过一个守护线程去看主线程它有没有完成任务，他如果完成任务的话释放锁，如果他没有完成这个任务，守护线程就会去再申请一段时间就是不释放这个锁。
说话人1 44:39
你怎么知道他已经删到哪儿了，你怎么知道他已经遍历到哪儿了？
现在有100万个，你肯定一开始只遍历一点点，删这一点点，你怎么知道哪些删过，哪些没删过，
说话人2 45:01
可能就还是要进行一些SQL的查询。
说话人1 45:09
怎么查？
说话人2 45:12
查最近的守护县城去，就是查这个版本号，如果查到大于10条的话，他就不是上一个锁，
说话人1 45:30
每次我每次都是从头遍历是不是有点浪费？是的。
说话人2 45:50
但是这个断点续传我不太会实现，我不知道它是怎么实现的。
说话人1 45:57
你记一下当前做哪个业务不就行了吗？做到哪个规则了？
说话人2 46:05
不可以吗？Ok可以，每隔几百毫秒就去记录一下，删到了第几条版本号，
说话人1 46:15
第几条版本，第几个规则
说话人2 46:17
对不对？一个规则会有很多个版本，
说话人1 46:24
但是你这个周期还是要删完这一个版本的东西。
说话人2 46:29
是的。
说话人1 46:32
我再假设假设你现在是你开始轮巡，比如说你10秒轮巡一次，10秒执行一次，结果你现在是单机，单机删它这个规则已经到了非常大的一个规则，1,000万级别的规则了，你单机也删不完了，单机一天都能上不完，你怎么能保证他一天删完？
说话人2 47:06
单机删不完的话，再设置一个时间，就是到白天的时候正常正常该有业务进来的时候，就去终止删除操作，
说话人1 47:29
为什么要终止？
说话人2 47:31
因为它删的话它可能会影响业务的性能，调用这个规则引擎的性能，但是
说话人1 47:38
你都删不完了，它只会越积越多。
说话人2 47:42
但是这个版本修改，它我们设计这么一个场景，就是它不会太经常的更改。
说话人1 47:52
好，我假设他就要现场修改，比如说入它的写入量要大于你的删除量，你现在我其实问题是你怎么能加快它的，你现在是单机删
说话人1 48:14
删是有瓶颈的，你怎么能加速是不是就要多机删
说话人2 48:19
集群，用Redis的集群。
说话人1 48:23
Redis集群和Redis集群有什么关系？
说话人2 48:39
多机删的话，每个机器负责一块的内容，可以给他就是编号
说话人1 49:05
你怎么分呢？
说话人2 49:06
根据机器数和规则的数把它平均分，
说话人1 49:13
把它平均分，你就相当于我规则是不断在增加的。你怎么分？比如说我现在你应该有个规则ID对不对？对规则ID，但现在有10台机器，我先把它搞成简单版本，固定了之后10台机器，你现在要分你怎么分？
说话人2 49:35
用一个类似快照的机制，先把当前之前的冗余删掉，然后后面的再进行一次这种操作。因为现在的场景是挂掉了，他好长时间没启动。
说话人1 49:55
没事，我们现在不考虑挂掉的情况，就正常的你现在有一堆的，因为你现在假设的场景是写大于删，不挂掉的场景下，你删的也慢，关键现在是别人现在就有100万条规则，然后你有10台机器你要怎么分？
说话人2 50:22
那就留两台出来用来写，剩下的8台用来删。
说话人1 50:30
好，上海吧台你怎么来分工的？他不是删除了吗？
说话人2 50:41
还是一个类似快照？删一批，然后等这批删完了再来出发，下一批是
说话人1 50:50
可以，只不过说你这8个机器我总要知道分工，我一起删我怎么删，我删哪些，
说话人2 50:59
通过快照把这些规则ID就是分出来，然后从上到下，比如0~9分给分给第一台机器，然后10~19分给第二台机器去
说话人1 51:17
做好了这个快照，怎么怎么通知给，首先快照怎么生成？再其次你这个规则你是手动的输给删除的进程还是怎么样？
说话人2 51:37
这个快照手动删除肯定是不太现实的，因为它因为他现在是写的操作量很大，那就要通过机器去实现这么一个能力。快照的话，那就把整个Rule_ID记录下来，就是遍历一遍，就是遍历一遍Rule_ID就可以了。
说话人1 52:20
然后你怎么分？你怎么告诉其中一台删除的进程，我要删哪些？
说话人2 52:36
通过管道？
说话人1 52:40
管道是机器单机的概念，多机的话会一个mq
说话人1 52:49
通过mq是吧？
说话人2 52:51
因为它 Http的话可能也行，因为它每台机器都发一遍就行了，每台机器都发一遍。
说话人1 53:03
是可以，但是也没问题，你现在要怎么做？你不是还有有机器在分吗？我这个任务要分，你找谁分？招生费，
说话人2 53:24
从里面选一个leader，搞一个leader的概念，由leader来分配任务，分给每台机器。
说话人1 53:37
分给每台机器，然后用HTTP的方式分给他。
说话人2 53:41
对，
说话人1 53:44
有个问题 Http，我调用的时候，比如分任务分完任务以后，本来这个任务应该是很大的，
我可能一可能一这一个任务要删除，10万个账号都有可能10万个就这个规则，但这个HTTP一直等他删完了再回包吗？还是怎么样？
答：
异步
问：
怎么实现异步呢？
说话人2 54:23
他首先HTTP传到了之后，先发送一个确认机制，相当于告诉他我这个消息发到了。
说话人1 54:33
好，
说话人2 54:34
然后再等这台机器删完了之后，再一步的调用HTTP，发送一个消息告诉leader说我删完了，然后就可以接下个任务了。这样
说话人1 54:53
你有必要告诉他删完了的这个东西吗。
说话人2 55:01
应该有，因为如果不告诉他的话，下个任务来了他还在删，或者就给他加一个工作队列，就是把leader给他的任务丢到工作队列里面去，
说话人1 55:18
这个队列是啥？
说话人2 55:24
这个队列就是要删除的数据的uid
说话人1 55:30
可以，但是这个队列你要用什么实现呢？
说话人2 55:36
什么实现？是指数据结构吗？还是？
说话人1 55:40
不是，你要自己写一个，你队列是拿个Redis再存一个队列，然后还是怎么样要搞
说话人2 55:55
用Java来实现，用Java里面
说话人1 56:04
自带的实现，这样的话不是一重启就没了吗？
说话人2 56:07
还要考虑重启。。。那就再来一个日志
说话人1 56:17
日志也不是不行，但是你日志你重启，然后你手动给它恢复，
说话人2 56:27
不根据日志里面的内容一一一行回复。
说话人1 56:35
你简历不都写了kafka了吗？你怎么不用Kafka了？
说话人2 56:44
因为我们Kafka用得很简单，就用了它的一个广播的能力
问：
广播的能力是怎么个解释法？
说话人2 56:56
用HTTP的话它发到每一台服务器上，就是要 HTTP更多的是点对点的通信，然后Kafka的话他就有一个广播的能力，然后消费者去消费就可以了，
说话人1 57:11
你知道Kafka他最多能接多少个consumer吗？
所谓的广播你所谓的广播就是多个consumer去消费它，消费者一个topic最多能多少个卡车板我
说话人2 57:27
不知道，因为我们服务器就5台。
说话人3 57:32
 Ok
说话人1 57:34
看起来做的比较简单，这个东西你们都应该是初期阶段对吧？
说话人2 57:38
对是的，
说话人1 57:39
好，我这边应该暂时没什么问题了，你还有什么问题没？
说话人2 57:46
好的，有的您好面试官，我首先请问一下您今天面试感觉怎么样？
说话人1 57:55
还我感觉你表达能力挺好的，不过这个项目实习的还是有点短，而且感觉比较简单。
说话人2 58:05
是的，它还有一些功能我没有说，
说话人1 58:09
不过其实重点考察还是其实搞一个大概就知道了。好，你继续还有什么别的问题？
说话人2 58:16
还有我大概什么时候能知道面试的结果，
说话人1 58:22
应该这周这周五就是下周应该下周之前肯定能知道。下周二三应该都有。
说话人2 58:34
好的，
说话人1 58:36
还有别的问题吗？
说话人2 58:38
请问一下我刚才的说的方案还可以吗？
说话人1 58:46
你说的是版本管理，咱们最后讨论的深入那个方案吗？对。
方案上是这么走的，而我也是一步一步往你那个方向引导的，只不过你最后说HTTP那个东西的话实际上太过复杂了，其实用一个卡夫卡就搞定了。
说话人2 59:09
是我一开始也想的是卡夫卡，但是我想到它是传的是不同的入ID，然后他用HTTP的话也不存在数据不一致的问题。
说话人1 59:20
倒不是你刚才不是也说了重启就没了。卡夫卡重启的话它还是在
说话人2 59:27
对，它有持久化。
说话人1 59:32
这种题我觉得你可以回去多多看一下，想想。然后后边的困，其实你这个东西最终还是想做大，做大的话你你看后边要怎么做，虽然你没有做，但是你可以知道怎么做，虽然你没有真正的去做。
说话人2 59:52
好的。
说话人1 59:54
还有什么问题？
说话人2 59:56
没有了。
说话人1 59:59
行行，没有的话咱们今天先这样，
说话人2 01:00:01
好的，谢谢面试官。

版本管理：
问：如果就是有很多的消息你要删的话怎么办。
答：给这个锁的过期时间设置的长一点。
问：如果这个时间你一天都删不完怎么办，这个锁也会过期
答：搞一个守护线程，看这个主线程有没有完成任务，如果没完成就申请延长锁的时间。
问：如果现在就是写大于读的场景，那有没有想过几台机器一起去删呢
答：可以，通过快照的方式把rule_id记录下来，然后发给每台机器去删
问：怎么去实现呢
答：计算总共rule的条数然后平均分发给每一台机器
问：这个任务怎么分配呢？
答：给几台服务器找一个leader，通过leader来统一分配
问：通过什么方式告诉从服务器呢
答：通过HTTP，发送给每台服务器。
问：如果这个请求处理不完呢，当场返回不了结果，HTTP就一直在这等着么
答：通过异步的方式，从服务器收到这个消息了之后立即返回一个收到，等任务处理完再返回处理完成的HTTP。或者给它加一个工作队列。
问：这个工作队列怎么实现，通过redis去实现吗
答：通过Java里面自带的实现
问：那如果这个服务器挂掉了怎么办，这数据不都丢了吗
答：那就再加一个日志，来记录操作。如果挂掉了就根据记录一行一行修复。
问：那你简历里不都写了kafka吗，为什么不用kafka来完成呢
答：我寻思发送这个删除操作到每台服务器上不需要保证数据一致性，所以用http也可以。
阿里国际商家链路二面
阿里国际商家二面.mp3
说话人1 00:02
16年到20年在长安大学读的是本科对吧？然后是21年到24年两年半的时间在波士顿大学读硕士对吧？对。这里面第一个问题就是本科毕业到硕士读硕士之间好像有概括的一年多对吧？这个是是自己去发展是去准备吗？还是什么原因？
说话人2 00:24
对是的，一开始是在备考国内的研究生，但是国内的研究生被调剂了，去了我不想去的学校，然后就没有去准备
说话人3 00:36
考
说话人2 00:36
申请国外的研究生。
说话人1 00:40
花了一年时间准备是吧？对。
这一年时间完全是在准备吗？还是说有在工作边看？
说话人2 00:52
因为他考研的时间他出分是是在2月多就2月多出来之后，发现结果不太好，然后后面就在准备申请，然后就在学语言。
说话人1 01:06
好的，一直在准备，然后1月份毕业的话，到现在是在哪家公司工作？
说话人2 01:18
现在目前没有工作再找机会。
说话人1 01:23
目前没有我们是吧？医院到现在是什么原因？是自己有发生身休息了一段时间，还是说一直没有好的一个工作机会？
说话人2 01:39
对，1月毕业了之后出去先旅游了一下，休息了一下，之前然后中间这段时间就在准备申请博士，但是就是因为家里的一些原因，然后跟家里商量了一下，然后就打算就不申请博士了，就在国内找班找个工作开始工作。
说话人1 02:03
你后面还有打算继续去读博吗？
说话人2 02:07
没有。
说话人1 02:09
就确定了是吧？对。你是几月份开始就是说做了一个决定，就不申博，然后开始去找工作？
说话人2 02:21
最近七八月份的时候。
说话人1 02:25
七八月份对。Ok，你现在应该花了一点时间，大概一两个月去工作，现在其他公司的现在面试进展怎么样？
说话人2 02:39
是有一些在面试的，然后有一个offer是
说话人1 02:45
哪个公司offer你拿到了？
说话人2 02:47
是北京的一个小公司。
说话人1 02:50
北京的小公司是吧？Ok我理解就是说因为你这个不是波士顿大学，应该QS是100对吧？
前100对整个学历毕竟还是不错的，这个好像offer现在拿的不是特别顺利，是不是？
说话人2 03:13
是的，因为有几个还在流程里面。
说话人1 03:17
还有哪几个在流程里面。
说话人3 03:20
什么
说话人1 03:22
偶尔还有哪些公司，你还跟着面的
说话人2 03:25
有字节，然后有腾讯，然后还有蚂蚁，
说话人1 03:33
现在有就到后面的接近下面，或者是在开始谈薪资这一块了吗？
说话人2 03:38
暂时没有，都在差不多二面这样子一
说话人1 03:44
二面是吧？对。
说话人2 03:45
Ok。因为我是8月多开始投的，然后他流程有的也比较长，
说话人1 03:54
理解你这个工作地点你现在是没有什么倾向对吧？哪里都可以。
说话人2 04:00
请问您是在哪里？
说话人1 04:03
在杭州，
说话人2 04:03
我就是倾向于杭州。
说话人1 04:07
倾向于杭州，好的，我看你简历里面写的在唯品会实习了一段时间，还有一个是23年是硕士毕业之前去实习的是吧？
Ok实习之后实习我没有选择在唯品会留下来吗？
说话人2 04:32
他提供了转正，但是我不想留在天津，我想留在杭州。
江浙沪这边我是想留在江浙沪这边，然后江浙沪这边杭州是第一首选第一选择。
说话人1 04:46
好的，了解。
说话人2 04:52
所以我投的阿里系就比较多。
说话人1 04:56
好的了解。对，然后编程语言的话，你刚才说了你得花点时间去学编程对不对？编程语言，然后对这一块就是Java的一个熟悉程度，现在怎么样？
说话人2 05:08
还可以
说话人1 05:11
还可以，在唯品会的话是用Java来做的对吧？你先给我介绍一下你在唯品会里面主要做了什么。
说话人2 05:20
好的，我们那个项目主要是一个我先讲一下它的业务背景，然后它的业务背景，我们做的是一个规则引擎，然后它设计的初衷就是为了把复杂多变的规则从硬编码里解放出来，然后用规则脚本的形式存放在文件或者数据库里面，然后规则的变更就不需要修改代码就可以使用了，然后这样就可以做到的比较高程度的灵活性。
然后这个规则引擎它是一个独立于业务系统的模块，然后他会负责一些规则的计算，然后包括有一些积分系统或者告警系统，他都会去实现这么一个逻辑复杂的这么一种组合。然后在有这个规则引擎之前，我们对接的那些系统没有对接的系统，他们那些本身的系统，他自己去实现一些逻辑比较复杂的代码块，它维护起来就比较困难。
然后在有规则引擎之前都是各个平台他自己去玩，然后他有了规则引擎之后，我们就会把他们这些这些这一部分抽到规则引擎系统里面来，然后让他们来对接我们，然后他们就不用关心底层的实现了。然后这个规则引擎它解决的就是一个复杂规则，它的各种组合，然后包括还有高频的这种规则的修改，然后它应用的场景，比如说有积分系统，然后这个积分系统如果要把积分计算的逻辑，把积分计算的逻辑和业务规则它抽象出来，然后分装，然后这样的话系统就能够基于这些规则，它自动的进行积分计算和管理。
比如消费规则满100的就积一分，然后积分系统就会监听用户的交易发生了之后，规则引擎就会根据匹配到的规则和事实数据去进行一些积分计算，然后积分计算完之后，完了之后会更新一些用户的积分余额，然后去记录一些积分变动的信息。
说话人1 07:33
好的，你们这个积分系统它不是具备了你们这个规则平台，规则中心我规则一些，你们如果说要去变动规则的话，是去你们的规则是配的代码库里面的，比如工程里面还是说是一个配置平台的配置？
说话人2 07:52
这个是在数据库里面的，然后我们会去动态的从库里面抽取一些，它有4张表跟规则相关的，有规则表，规则表关联的、有属性、有因子有动作，然后他会去根据这些表去查，然后拼接成一条规则。
说话人1 08:13
 Ok，也就是说你们是把那个规则写到表里面去，然后执行的时候从表里面读出来再去执行对吧？
说话人2 08:20
对，然后我们只是完成了这么一个功能，然后他具体去配置这个规则的话，不是由我们来完成的，是由业务模块他们自己去调用我们这个规则引擎，我们会提供给他们一个可视化界面，然后他们会通过一些比如这里填个属性年龄，然后中间会有大于小于，然后这边会有值，然后它去根据这么一个页面去去配置规则，
说话人1 08:52
理解。你们这个规则就是说规则就是上游的业务系统有可能会变对吧？有可能会变有可能会更新，但是你们去做规则执行的时候，你们是每次都做数据库实时查询规则，还是会去做一些比如缓存之类的去提升性能，
说话人2 09:11
我们是有缓存的，通过用redis然后它有一些预热，它每次启动的时候会去把一些热点数据放到redis里面，然后它刚启动的时候服务打过来就可能会比较快的响应。
说话人1 09:30
好的，这里面就是说如果下游上游的业务规则更新了，你们这个是从什么机制来保证，就是说你们保存的数据不一致的？
说话人2 09:41
这个是有一个规则的动态加载，然后这也是我们一个功能。然后它首先我们会连到数据库，然后设计好数据表，然后会把规则的配置存到表里面，然后在程序运行的时候，我们就可以调用一个重新加载的接口reload，然后来进行动态的加载。然后再调用reload的时候，首先会通过一个叫kieRepository的仓库从DB里面去加载所有的规则，然后拿到规则之后，通过一个主要是它里面自带的一个kieService，然后来加载规则，然后加载完成之后会把数据放到我们内存的文件系统里面，通过一个KieFileSystem，然后去构建一个kieBuilder，然后通过一个某个方法，然后会去构建一个虚拟的文件，然后自动去构建一个题目。然后检查文件的时候，如果存在错误就抛出异常，如果没有错误的话就会构建一个kieContainer，然后会去把原来的container给替换掉，然后这样的话我们容器里面就放的是我们数据库最新的数据，然后我们就实现了一个从数据库里面动态加载的这么一个过程。
说话人1 10:56
好的，您这个过程我听了一下，我想核心再想确认一下，就是说因为你刚才说就是说你们这个是一个底层的服务，然后上游交给业务系统去自己去做这个规则的变更和变更，跟规则的调用的对不对？
然后这里面就是说规则变更之后如何，因为你们这个规则已经我理解一个持续性的运行的服务对吧？可能不不断的有规则，现阶段有规则有变更，那就是说你们是什么时间触发这个规则变更，就是你们怎么感觉到这个规则是有变更的？
说话人2 11:50
我记得是前端，就是在前端会有一个他会写一条规则进来，然后我们会展示一个他有没有写完，是他协调规则会申请，然后他如果我们这边还没有校验通过的话，就会给他展示一个处理中。然后他如果如果过长时间都没有返回处理成功的话，它就要重新去配一条什么数据的一个规则，然后发到我们的系统里面来。
说话人1 12:32
也就是说你们是每次都有相当调用是吧？我调过去给你规则了，你们是把所有的规则都缓存起来了吗？还是说有一部分
说话人2 12:45
只是一部分是这个是由业务人员来负责的。这个不是我们来配置的。
说话人1 12:51
缓存也是业务来配置的吗？
说话人3 12:54
是的。
说话人2 12:55
这不对，这个不是是热点数据它会加载到release里面吗嘛，会根据
说话人1 13:01
怎么你们的热点数据逻辑是怎么处理的，
说话人2 13:07
是加载超过最近被频繁调用的一些数据。
说话人1 13:15
LRU是吧？
说话人3 13:17
对，
说话人2 13:18
LRU知道的，
说话人1 13:20
你们那个策略是llu对吧？有一个固定的固定时间，如果最好多长时间没有备用就会自动过期，是这意思吧？
对是的。好的，说到这点，如果说我们用Java的一个API去实现一个LRU一个典型的LRU我们应该怎么去做？
说话人2 13:47
用Map吧
说话人1 13:50
能给我说一下逻辑吗？
说话人2 13:57
请问能具体一点吗？
说话人1 14:01
就是从 Java不是提供了一些集合类对吧？
有列表的，数组集合的列表集合的，包括 MAP集合，还有什么其他的一些可能，比如说我们通过这些集合能够去实现一个LRU的缓存的容器，
这里面LRU的策略可以自己定义，但是就是说我们如果让你来去想一想，结合lu的特点，然后我们Java是集合框架里面的一些特点，你觉得怎么去比较合适的去给实现出来？
说话人2 14:46
首先需要去定义一个LRU的大小，
说话人1 14:52
这个都可以没关系。
说话人2 14:54
定义一个大小之后，通过用数组或者链表，通过用数组或者链表放入最近的这个程序，只要进程只要这个线程只要运行了，就把它放到链表里面去。然后遍历链表，然后还需要一个东西来存一下，最近有哪些进程，然后遍历一下容器，把链表里面没有的进程从页框或者页面里面替换出去。
说话人1 15:53
你能跟我说LRU它的一个
更新机制，我们可以重新去从lru它的本身的定义，然后再去看一下就是说我们那个容器里面到底是哪些东西可以天然的去实现 lru
说话人2 16:18
 lru它应该是最近最少使用算法，然后它首先会有一个进程编号，然后根据进程编号，它会有最近调用的次数，什么
说话人1 16:34
叫进程编号？
就是
说话人2 16:37
程序计数器，就是程序每个程序都会有一个
说话人1 16:44
不应该叫竞争点好吧，因为我们前面就是一个数据，没有什么竞争的概念，
说话人2 16:49
好的就会有这么一个数据，然后这个数据肯定是有编号的，然后我们会根据这个编号会去把它最近它只要被用过一次就会往它对应的，相当于剑指对吧？K value往它的 value里面，value存的是它最近调用次数，然后 value去加一，等下一个数据不在内存里面的时候，我们就会去遍历 map，然后把 value最小的这么一个数据给它替换出去，大概是这么一个逻辑。
说话人1 17:48
如果这个逻辑的话，我们 Java的如果是这个东西，如果说它是要两两存两个类型的数据，那么肯定是一个map结果对吧？不能是一个数字。
说话人2 17:59
对是个map结构，
说话人1 18:03
能够实现迈克要实现推进这种使用的一个淘汰机制的话，
说话人4 18:08
这
说话人1 18:09
是如果我希望你可以制造出来一个实现，也许不是最完美的，但是有个逻辑就可以。没问题。这样能够讲清楚吗？
说话人2 19:10
有点模糊，我做过类似的题，请问能给一个具体的题，
说话人1 19:18
你什么意思？
说话人2 19:20
可以把它的编号数据它的某个编号给出来，然后通过用算法的形式把它写出来。
说话人1 19:41
好的，你可以再想一想，如果你等下想想到了我们可以再聊，我先把这个问题先先暂停一下，先终止到这，我们后面再聊聊其他的。在Java里面我们要去实现一个单例应该怎么评估？
说话人2 19:59
在Java里面实现单例有两种一般，一个是懒汉，一个是恶汉。
然后他懒汉和饿汉他首先是懒汉，它有一个资源加资源浪费的问题，然后它是在类加载的时候直接创建对象，然后初始化单例对象，然后如果从代码上来说的话， class里面有一个private，然后对象是私有的，然后会有一个 static的一个 instance，你有一个新的对象，然后把它赋值给 instance，然后提供一个公共的接口来return instance，然后也还有一个对恶汉，然后他是比较懒，顾名思义他比较懒，其实是一个懒加载，然后他在第一次被使用的时候才会被初始化。
然后首先创建一个私有的构造方法，防止其他调用的地方直接拗这个对象，让创建出来的对象就不是单例对象了，然后创建一个私有的变量来保存代理对象，然后再提供一个公共的方法去返回代理对象。然后他还有几个问题，首先他必须要加volatile，然后他加volatile是为了解决可见性的问题，还有一个是为了防止指令重排序，如果不加volte的话，比如说有一个线程一在执行到构造方法的时候，可能就会指令重排序，然后在创建内存空间之后，先把内存地址赋给实例对象，然后再在内存空间里面初始化对象，然后这个时候线程二来了，然后判断实例的对象是是不是null，然后但是这个时候线程一它还没有把对象给实例化完，然后这个时候线程二可能就会得到一个实例化一半的对象，然后这个时候可能就会导致线程出错，所以懒汉他一定要加volatile。
说话人1 22:38
单例模式的我们知道就是说在整个 Java容器里面，就是所有的执行上下文都只有一个对象应用对吧？这个时候我们会在实践里面有一个原则就是说我们在单一对象里面不能让这个对象有属性，有它的实际属性。你可以给我讲，我们说一下你的理解为什么会有这种要求，说一个单例对象里面不能有私有的成员变量，
说话人2 23:12
私有的它应该是防止其他的地方直接调用对象，
说话人1 23:24
直接因为单一对象你是没法让它new的，我们可以控制起来，比如说把构造函数私有化起来，
说话人2 23:33
我的理解他不能这么干，首先肯定是有问题的，那问题他会在创建的时候，。。。不好意思可能不太了解。
说话人1 24:02
我可以稍微提醒一下，就是说因为单例对象所有的线程引用的都是同一个对象，对不对？对。如果都是同一个对象，这个对象，它有一个成员变量就意味着什么？就意味着所有的线程持有的都是
说话人2 24:25
同一个对象，同一个对象的一个对象里面的属性
说话人1 24:31
同一个对象属性会带来什么问题，
说话人2 24:34
可能会有线程不安全的。
说话人1 24:37
对，因为现成数据会错乱对不对？因为就是说这个数据不是我现成的私有的，是全局共享的，我改变我这个数据其实会影响到其他行程执行对不对？对是的对吧？这个就是现在安全的问题，所以我们就是说如果你是有局部变量，你这个就不能实施代理，你必须要每次创建新的对象出来对吧？对。好的，我提醒到这后面还有问题，就是说如果说我们现在说有这个问题，然后恰好某个人他就写了这种情况，我们如果对要修复这种问题，你觉得怎么去做？来去解决线程这个问题？
说话人2 25:18
我觉得可以在前面加Synchronized这么一个关键字，然后它加了Synchronized，它是一个重量级锁，然后它能保证这个线程被修改了，它其他的线程可见，然后它还能保证有序，它不会让指令重排序。然后差不多就是这样。
说话人1 25:42
我们就是说在通过手段技术来保证线程执行的有序，对吧？锁的话，我们除了生物拉斯的内置锁之外，我们还有JavaJDK的直接可以提供的其他的锁，比如Lock他们这些锁有什么区别吗？
说话人2 26:00
好的，首先synchronize的它是一个重量级锁，然后ReentrantLock它是一个可重入锁，然后它支持公频锁和非公频锁，然后它也原来是Lock，它好像是通过AQS来维护一个阻塞队列。然后Synchronized和Lock， Synchronized它是关键字，然后它是用C++实现的好像，然后Lock它是由Java来实现的，然后Synchronized的，它是会自动释放同步块里面的锁，然后用Lock的话，它需要用Unlock来手动释放锁，然后它们两个都属于悲观锁，然后然后Lock它还提供了一些 Synchronized没有的功能，比如有公平锁，然后有可打断或者可超时，然后Lock它还有一些其他的实现类，比如ReentrantLock，还有一些 ReentrantLockReadWriteLock，然后性能的话是 Synchronized它做了一些优化，然后它会有一些锁升级的概念，就比如有偏向锁轻量级锁，然后有重量级锁，然后它的性能就会还不错。然后在锁竞争激烈的时候， lock的话可能会提供好一点的性能。
为什么Lock比Synchronized性能好
在Java中，Lock接口（尤其是ReentrantLock）相较于Synchronized关键字在锁竞争激烈的情况下性能更好，主要原因在于Lock提供了更多的灵活性和更好的锁管理机制。这些机制在高竞争场景下能够减少锁争用的开销，提升性能。以下是几个具体的原因：
1. 可中断锁（Interruptible Lock）
ReentrantLock支持中断锁获取的线程，这意味着当一个线程试图获取锁但被阻塞时，可以响应中断信号。这样，如果线程在等待获取锁时不再需要锁（比如被取消了任务），它可以被中断并迅速返回，从而避免不必要的等待时间。
相比之下，Synchronized是不可中断的，一旦线程进入等待状态，它只能在获取到锁之后才会恢复运行，这可能会导致线程长时间阻塞。
2. 尝试锁（Try Lock）
Lock接口提供了tryLock()方法，这个方法允许线程尝试获取锁而不必一直等待。这对于那些能够处理锁不可用情况的应用程序非常有用。通过使用tryLock()，线程可以在获取锁失败时执行其他任务或者做出不同的处理逻辑。
Synchronized没有这种功能，线程在尝试进入同步块或方法时如果锁不可用，只能等待，直到锁被释放。
3. 公平锁和非公平锁
ReentrantLock允许使用公平锁（Fair Lock）或非公平锁（Non-fair Lock）。公平锁按照请求的顺序获取锁，避免了长时间等待的线程饥饿现象。但在高竞争场景下，非公平锁性能更好，因为它会让线程在锁释放时直接竞争锁，而不是按照顺序来，这样可以减少上下文切换，提高吞吐量。
Synchronized内部实现的是非公平锁，但并没有提供选择公平锁的机制，因此缺少了灵活性。
4. 精细的锁管理
ReentrantLock允许更精细的锁管理。它支持手动的锁和解锁，这使得在一个方法内可以灵活地进行锁的控制，比如在锁住之后可以在某些条件下提前释放锁。它还支持锁的重入特性，即同一个线程可以多次获取同一把锁而不会死锁。
Synchronized是基于JVM的内置锁，使用的地方和范围相对固定。它是通过进入和退出同步块或方法来自动进行锁的获取和释放，缺少了灵活性。
5. 减少上下文切换
ReentrantLock在竞争激烈的情况下可以减少上下文切换。例如，使用Condition对象，线程可以等待特定的条件（而不是盲目地等待锁释放）。当条件满足时，线程可以被通知和唤醒。这种机制减少了线程在无谓等待中的上下文切换开销，提高了整体性能。
Synchronized会导致更多的上下文切换，因为它不支持条件对象，所有等待的线程都会直接等待锁释放，当锁被释放时所有线程都会被唤醒竞争锁，这可能导致更多的调度和切换。
总结
在高锁竞争的场景下，Lock接口，尤其是ReentrantLock，提供了更加灵活的锁管理方式，包括可中断锁、尝试锁、选择公平锁或非公平锁、精细的锁控制和条件等待等。这些特性使得它能够更有效地管理线程的竞争和锁的获取，减少上下文切换的开销，最终提升了在高并发情况下的性能表现。而Synchronized由于其较为简单和固定的锁机制，缺乏灵活性，在高锁竞争的场景中性能表现不如Lock。
说话人1 27:30
好的，去除了我说的锁之外，还有什么方式可以解决线程安全？
说话人2 27:39
或者用ThreadLocal
说话人1 27:44
ThreadLocal它内部是通过什么结构去保存现成的上下文数据的？
说话人2 27:51
ThreadLocal应该是一个ThreadLocalMap类型的成员变量，然后是把ThreadLocal自己作为key，然后把资源作为value放到map里面，
说话人1 28:07
所以包括它内部的map，它的k的引用类型是哪一种你知道吗？
说话人2 28:15
是弱引用。我不太清楚，
说话人1 28:20
你知道Java有几种引用，
说话人2 28:23
有强引用，有弱引用，还有虚引用，还有还有一个什么来着？还有一个
说话人1 28:35
软引用
说话人2 28:37
软引用，
说话人1 28:39
这几种引用一般情况我们不会用对吧？一般都是正常情况下强引用，其他引用的他们一般是什么场景会用或者怎么去创建出来，你了解过吗？
说话人2 28:49
软引用，软引用它就是首先一个对象它有用，但是它不是必须的，然后它内存空间足够的时候， GC它不会回收它，然后在内存空间不够的时候，GC它就会在OOM之前去把它回收掉，然后弱引用它就是一个这个对象可能有用，但不是必须然后GC它一旦发现了，它是个弱引弱引用它一定会被回收，然后不管它内存空间是不是足够，然后信用就是一个对象，它没用了，然后它所有的时候都可以被回收掉。
说话人1 29:25
Ok，我们如果去Java实现一个对象的深拷贝，应该怎么
说话人2 29:40
去实现一个深拷贝的话，省拷贝就是两拷贝会完全复制整个对象，然后包括对象里面包含的内部对象，要去深拷贝，要去堆里面重新分配，重新声明一块内存，然后把这块的内存复制给把之前的那块内容复制到新的内存里面去。
说话人1 30:20
从内存的操作来说，可以这么去看具体实现怎么样怎么做，
说话人2 30:26
具体时间我有点忘记了。
说话人1 30:32
 Ok你在实习阶段对这一块你收获是有什么？技术上的收获没有？
说话人2 30:45
好的，这块我觉得收获还是蛮多的。首先我在学校里面的项目它不会是一个很大的项目，然后它就是一个单独的模块，然后但是在公司里面这个项目的话，它可能会跟其他的模块之间有一些交互，然后有一些通信，然后我自己完成的也是某一个小模块。然后我知道了在Java里面他该怎么表达他还能这么干。然后还有包括
我们做这个东西，我参加了他们的讨论，他们讨论我一开始因为没有什么经验，也说不上话，只能听他们在讨论，然后他们就会讨论一些包括应用架构之类的架构，然后还有业务架构，或者还有一些部署架构方面架构方面的问题，然后应用架构就是他给我们做了一个服务拆分，然后他们也讨论了为什么要做服务拆分，
然后他其实也可以不做服务拆分，但是他们的最后讨论的结果就是去做了一个服务拆分，然后还有一些比如工厂模式在这个项目里面的应用，然后包括我们有一个规则的解析，它是用了一个工厂模式的思想去完成的模块的内容，包括还有一些线上有一些并发的问题，我做的模块有一些并发的问题，但是我并发我的问题，我的那些并发度不高，所以我用的很简单，就是用了一个cscs的思想来解决了这些问题，其实收获还是蛮多的，但是我目前只能想起来这些了。
说话人1 32:44
你说的这些确实很多，但是都比较泛化，有没有你觉得对你来说是一个比较大的影响的收获？
说话人2 32:58
我觉得架构我以前来去写代码，更多的是从学生的思维，以前也不是面向对象，就是一个函数从头写到尾，然后它就结束了。然后在这个公司里面它会把一些服务做一些拆分，然后去做一些代码上面的解耦，然后解耦了之后，这些代码可能就比较好负责维护，比如还负责扩展，然后这一块出了问题就直接可以去找这一块来改，然后就不用去管业务上的有什么问题，其实给我的思路上的改变提升扩展还是挺扩展了我的思维，我以前还不知道能这么干。
说话人1 33:50
好的，我们在我们在Linux操作系统里面，我们要去查看服务器的一些状态，我们比如说要看整个进程运行的一个负载情况，应该用什么命令来看？
说话人2 34:05
我不太懂Linux，不好意思，
说话人1 34:09
你的专业不学这个吗？
说话人2 34:12
没学过。
说话人1 34:15
也学过是吧？
说话人2 34:18
对，
说话人1 34:19
你硕士学的计算机信息系统主要学什么？
说话人2 34:27
他很多包括有学Java，有学Python，然后有学有学Web，然后还有一些理论课，还有一些Java的基础，不管是什么的基础，我选的语言是Java，然后他会教一些数据结构算法，
说话人1 34:48
你这个硕士正学年是正常的，我感觉有点久，现在不是正常，一两年就学完了。
说话人2 34:55
我那个是三年，但是我是提前修完了，
问：
三年现在还美国这边还是三年这么久，
答：
有三年的，有两年的，一有一年的，然后我修的是三年的。
问：
但是我感觉你这个都是偏应用方向的
说话人2 35:20
吧？对是的。
说话人1 35:22
应用反应正常来说都是比较快一点的，一两年的这种
说话人2 35:26
我不太清楚，但是他们设计的就是
说话人1 35:31
设计就三年是吧？
对，
说话人2 35:35
然后有一些理论课，然后一学期也没有碰代码，
说话人3 35:39
就
说话人2 35:41
有些理论课就也没有应用上面的东西，然后就会写一些论文什么的，然后这些论文
说话人1 35:55
你发了论文了
说话人2 35:56
没有？只是作业。
说话人1 36:00
你们毕业不要求发论文是吧？是的，也没有参加过一些编程竞赛，
说话人2 36:11
没有，之前去hackathon上玩了一下，然后也没什么成果。
说话人1 36:16
Ok，你觉得你本科的专业成绩怎么样？
说话人2 36:26
然后本科的专业成绩
一般前50%，本科没有再好好学习。然后研究生之后就感觉不太行，然后需要好好学一下，然后研究生成绩就还可以。
说话人1 36:41
这个成绩大概能够排名的话大概是多少？
说话人2 36:46
研究生吗？我觉得应该有前10%，因为我有很多课都是A
说话人4 36:54
这样
说话人1 36:54
是吧？好的，你这边对现在大语言模型这种这门技术有了解吗？
说话人2 37:12
这个不了解，请问我们会做这一块吗？
说话人1 37:19
对，因为但是这个是现在技术的一个趋势，对吧？我们会很多接触到元宝现在出各种各样的事情。完全没有了解是吧？
说话人5 37:31
是的，
说话人2 37:33
因为我在准备面试都在背背8股什么的。
说话人1 37:41
好的，英语怎么样？英语应该不错，
说话人2 37:44
英语还可以，阅读文档没问题，然后简单对话也没问题。
说话人1 37:51
你能用进去简单介绍一下你们的学校
说话人3 37:56
吗？
说话人2 38:02
这种介绍型的可能不太行，我需要先写个稿子，就是写稿子应该也没问题，
说话人1 38:09
当时也所以就是说叫什么？听说好像稍微差点，然后读写强一点对吧？
说话人5 38:17
对
说话人1 38:22
好的，行，我看你spring应该有了解， Spring有没有了解？
说话人2 38:28
 Spring有一些了解，
说话人1 38:31
你的surprise最大优点是什么？
说话人2 38:35
我觉得spring它首先是有一些优点，但是它bring它不如spring，boot好用。
然后它spring它有一些包括IoC和AOP，首先是它的最出名最广泛最普遍，反正就是最广为人知的某两种优点。
然后IoC它是控制反转，然后它他就是我们在使用spring的时候，他可能会要先建一些类，比如UserService，然后他会用一些注解，比如说Autowired然后在程序运行的时候用的是具体的UserService对象，但是我们程序员只写了类，然后这些对象的创建，包括对象里面属性的赋值，它都是通过spring来帮我们做的，然后控制，然后它反转是因为我们就是自己控制对象的创建和对象属性的赋值，没有spring的时候，但有了spring之后，这两件事就不用我们做了，然后我们只需要自己定义类，然后这些属性的赋值就由spring交给spring来完成了。然后用了这个的话，它可能会简化一些，简化一些，就是减少很多代码量。但是交给spring了之后，我们就不需要来关心这些东西。如果没有的话，如果类再多一点，然后类里面的属性再多一点，那么就代码会很多，然后这个逻辑也很复杂，然后我们维护起来也比较困难。
说话人1 40:17
你刚才说spring boot比spring更好用对吧？你觉得spring boot相对spring它的优点是什么？
说话人2 40:27
 Spring boot，因为我们配置也不需要自己，也不需要我们来配置，是有其他人配置好的，但是在用的时候，我自己写一些练习项目的时候，就会发现 spring他要去配置很多东西，它要有一些什么叉庙配置，然后还有一些什么包括proper的配置，还有它里面还有反正它里面要设置的东西有很多，一步一步设下来，可能半天就没了，然后用split的话，它会自动的帮我们去管这些事情，然后他加一些注解就可以了，非常的方便。
说话人1 41:11
好的，你有没有研究过就是自己去构造一个私人的组件，让其他人用这个组件可以快速的去做到开箱即用？
说话人2 41:26
我没有考虑过，我之前看了一个教程是打算去试一下，是一个实现一个编译器，但是还没开始动。
说话人1 41:38
还没来得及搞是吧？对好的。你觉得从技术角度来说，你的强项是什么？
说话人2 41:51
我的强项就是因为是科班出身，所以一些代码上面的东西就不如就比那些非科班的要强，我底层的原理差不多都知道，所以包括一些新东西的话，他可能上手也会比较快一点。
说话人1 42:16
你的弱项是什么？
说话人2 42:17
之前的应用弱项，我可能不太擅长跟人打交道，
说话人1 42:26
你的性格
说话人2 42:30
是吧？可能还行，也可能不太行，我也不太确定你们。然后包括交给我的事情，我可能因为性格上的一些原因可能有强迫症，然后他给我的事情我可能搞不定的话，我就必须要想办法把它搞定，然后可能会有这种强迫性的好
说话人1 42:56
的，你跟你同学相处的
说话人2 43:01
都还可以。
说话人1 43:06
对，我没有问题了，有没有什么问题要跟我反馈一下？
说话人2 43:10
好的，请问一下这次面试您对我的感觉怎么样？
说话人1 43:18
感觉还行，但是也有一些地方我觉得也可以去改进，
但是还是要去综合去看分析一下，推动你的一些优势，然后你面试上可能觉得存在的一些稍微短一点的短等等，然后会综合起来去做一个考虑。
说话人2 43:43
好的，了解，请问这个结果大概什么时候能有一个反馈？
说话人1 43:53
我们正常2~3两三个工作日就能有反馈了，对，如果两三个工作日我们讨论之后觉得没问题，应该就是在两三个工作日会约你坐下来面试。如果我们觉得可能暂时不太合适，我们也可能会在就是说最多一一周会有就是说一个邮件通知，对，大概是流程。
说话人2 44:15
好的，请问一共有几轮面试？
说话人1 44:19
加上这一轮的话，后面就有两轮就是加一个技术主管和一个 hr，但是他们两个有可能一起面对。
说话人2 44:28
好，了解了，请请问一下我们这个部门的话之后的业务方向会是什么？
说话人1 44:38
我们这个部门是阿里公司集团的一个业务单元，是按icbu阿阿里巴巴到com，就是做全球的跨境b to b电商业务的，然后这是一个大业务范畴，然后这里面有一个是b to b的，一个是电商，一个是全球化的，基本上是组合起来就是我们的业务模式。然后这里面就会涉及到电商里面商家、买家、商品，你包括交易履约、担保支付，以及什么像一些风控合规等等的一些这些业务单元，这些业务模式在我们这里都会有。
大的我们这个部门是主要做商家领域的，商家领域就是说解决商家的入驻，商家的留存，解决这个问题，以及商家怎么再提供一些更好用的产品工具一些工具，让商家在这里面能够去提升它的经营效率，降低它的经营成本，这个是我们作为商家团队要解决的问题，我这边是负责全球化这一块的，就是说在商家里面他也负责两块，一个负责国内的商家，一个负责国外全球化的商家。
国内商家就是中国的商家，因为中国商家之前一直是网站的一个底盘，就是说大我们之前的业务，但是大部分主要部分是中国商家，然后买家是全球买家，但是中国商家它现在已经到了瓶颈了，就增长瓶颈了，我们现在要把这个瓶颈再打开，那就是把全球化业务再去往上做一做，去把全球化的深度商家规模提升上来，现在主要就是在负责全球化的商家的引入，商家的留存，以及商品的商贩以及商品的前台运营，去把商家商品这件事情能够做得更好，去带来一些新的增长空间，这个是我们大致的一个业务范畴。
说话人2 46:20
好的，了解了，请问用到的技术栈会有哪些？
说话人1 46:27
技术栈的话一个就是Java相关的Java分布式Java的一些技术栈，比如Java核心技术，然后分布式的一些架构， Rpc消息缓存事物，对吧？然后容器层面就是一个是 sprint相关的，然后还有就是克拉尔相关的一些技术，这是Java层面。
另外一个就是说我们对数据和AI这一块也会有一些有一些涉猎，对吧？一个就是数据驱动能够去做一些数据分析，以及做一些数据归因相关性分析，去看一下就是说整体的
整个数据效果，包括从数据里面去洞察一些新的机会，这是数据层面，AI层面就是现在我们通过AI去做整个不管是业务层面的企业，还是整个公司层面的提效，我们通过去不断的去尝试去把整个从AI去改变整个商业模式，大概是做这么几件事情，几个进展。
说话人2 47:26
好的，了解了。
我这边没什么问题了。
说话人1 47:32
行，我们今天面试先到这好吧？后面就是说我们这边会讨论一下，如果有机会的话，我们会尽快通知，你好，好
说话人3 47:39
的。
说话人1 47:41
好的，先到这，好，
说话人2 47:42
谢谢您。
说话人1 47:43
拜拜。
